#!/bin/bash

#exec - execute command in /bin/bash, and get its result
#espeak - get voice message of text (use espeak from linux repo)
#speakru - get voice message of text on russian (use festvox-ru from linux repo)
#sayru - say in speakers on russian

source config

#Array_Element="0"
#if [[ -v RAM_JSON && -n RAM_JSON ]]; then
function UPDATE_ID(){   cat "${RAM_JSON}" | jq -rMa .result[].update_id ; }
function CHAT_ID(){     cat "${RAM_JSON}" | jq -rMa .result[].message.chat.id ; }
function CHAT_TITLE(){  cat "${RAM_JSON}" | jq -rMa .result[].message.chat.title ; }
function CHAT_TYPE(){   cat "${RAM_JSON}" | jq -rMa .result[].message.chat.type ; }
function FROM_USER(){   cat "${RAM_JSON}" | jq -rMa .result[].message.from.username ; }
function FROM_ID(){     cat "${RAM_JSON}" | jq -rMa .result[].message.from.id ; }
function FROM_IS_BOT(){ cat "${RAM_JSON}" | jq -rMa .result[].message.from.is_bot ; }
function MESS_NUMB(){   cat "${RAM_JSON}" | jq -rMa .result[].message.message_id ; }
function MESS_DATE(){   cat "${RAM_JSON}" | jq -rMa .result[].message.date ; }
function MESS_TEXT(){   cat "${RAM_JSON}" | jq -rMa .result[].message.text ; }

# server feedback when send anything to server with curl
# must be 'true' or 'false'
function sfb_status(){ echo $( cat "${SFB_JSON}" | jq -rM .ok) ; }
function sfb_messID(){    cat "${SFB_JSON}" | jq -rMa .result.message_id ; }
function sfb_chatID(){    cat "${SFB_JSON}" | jq -rMa .result.chat.id ; }
function sfb_chatISBOT(){ cat "${SFB_JSON}" | jq -rMa .result.chat.is_bot ; }
function sfb_chatUSER(){  cat "${SFB_JSON}" | jq -rMa .result.chat.username ; }
function sfb_fromID(){    cat "${SFB_JSON}" | jq -rMa .result.from.id ; }
function sfb_fromUSER(){  cat "${SFB_JSON}" | jq -rMa .result.from.username ; }
function sfb_fromTYPE(){  cat "${SFB_JSON}" | jq -rMa .result.from.type ; }
function sfb_date(){      cat "${SFB_JSON}" | jq -rMa .result.date ; }
function sfb_text(){      cat "${SFB_JSON}" | jq -rMa .result.text ; }
function sfb_error(){     cat "${SFB_JSON}" | jq -rMa .error_code ; }
function sfb_err_descr(){ cat "${SFB_JSON}" | jq -rMa .description ; }
#else
#	echo "Json file not set!"
#fi

function parse_text(){
	VAR=$(cat $CMD_ARGS | awk '{print $1}')
# find commands in message
	if [[ $( echo $VAR | awk '{gsub(/\/\w+/,"TRUE",$0);print $0}') == "TRUE" ]]; then
		case $VAR in
			"/espeak" )
				echo "espeak" > $CMD_FLAG	;;
			"/speakru")
				echo "speakru" > $CMD_FLAG	;;
			"/exec" )
				echo "exec" > $CMD_FLAG	;;
			"/sayru" )
				echo "sayru" > $CMD_FLAG	;;
		esac
# if get flag, execute apropriate command
	elif [[ $(cat $CMD_FLAG) != "" ]]; then
		case $(cat $CMD_FLAG) in
			espeak )
				send_Tvoice $CMD_ARGS
				;;
			speakru )
				send_TvoiceRU $CMD_ARGS
				;;
			exec )
				RESULT=$( $(cat $CMD_ARGS) )
				send_Tmess "$RESULT"
				;;
			sayru )
				sayru_alsa $CMD_ARGS
				;;
		esac
		echo "" > $CMD_FLAG
# if not find any, do echo
	else
		[[ "$(CHAT_TYPE)" == "private" ]] && send_Tmess $CMD_ARGS
	fi
}

# Make logs
function log(){
	echo -e "[$(date +"%x %X")] $1" >> status.log
}

function send_Tmess(){
	local MESSAGE="$(cat $1)"
	curl $CURL_ARGS -X POST "${URL}/sendMessage?" -d chat_id=$(CHAT_ID) -d text="${MESSAGE}" # 2>&1 > /dev/null
	log "[STAT] send message with exit status ${?}"
	log "	${MESSAGE}"
}

function sayru_alsa(){
	# func wait for /path/to/file like first argument
	local VOICE_FILE="$TEMP_DIR/$(MESS_DATE)_$(FROM_USER)"
	cat $1 | text2wave -o ${VOICE_FILE}.wav
	play -q ${VOICE_FILE}.wav > /dev/null 2>&1
	[[ "$(uname -n)" == "orangepizero" ]] && mv ${VOICE_FILE}.wav $DEST > /dev/null  2>&1 || rm -f ${VOICE_FILE}.wav
}

function send_Tvoice(){
	local VOICE_FILE="$TEMP_DIR/$(MESS_DATE)_$(FROM_USER)"
	espeak -w ${VOICE_FILE}.wav "$( cat $1 )"
	ffmpeg -i ${VOICE_FILE}.wav ${VOICE_FILE}.ogg 2>&1 > /dev/null
	curl $CURL_ARGS -X POST "${URL}/sendVoice?chat_id=$(CHAT_ID)&" -F "voice=@${VOICE_FILE}.ogg" # 2>&1 > /dev/null
	log "[STAT] send response with exit status ${?}"
	log "	$( cat $1 )"
	[[ $(uname -n) == "orangepizero" ]] && mv ${VOICE_FILE}.wav $DEST > /dev/null 2>&1
	rm -f ${VOICE_FILE}.wav
	rm -f ${VOICE_FILE}.ogg
}

function send_TvoiceRU(){
	# func wait for /path/to/file like first argument
	local VOICE_FILE="$TEMP_DIR/$(MESS_DATE)_$(FROM_USER)"
	cat $1 | text2wave -o ${VOICE_FILE}.wav
	ffmpeg -i ${VOICE_FILE}.wav ${VOICE_FILE}.ogg > /dev/null 2>&1
	curl $CURL_ARGS -X POST "${URL}/sendVoice?chat_id=$(CHAT_ID)&" -F "voice=@${VOICE_FILE}.ogg" # 2>&1 > /dev/null
	[[ $(uname -n) == "orangepizero" ]] && mv ${VOICE_FILE}.wav $DEST > /dev/null 2>&1
	rm -f ${VOICE_FILE}.wav
	rm ${VOICE_FILE}.ogg
}

function send_Tphoto(){
	local PHOTO="$1"
	curl $CURL_ARGS -X POST "${URL}/sendPhoto?chat_id=$(CHAT_ID)&" -F "photo=@${PHOTO}" # 2>&1 > /dev/null
}

function get_Updates(){
	echo "$(curl $CURL_ARGS -X GET "${URL}/getUpdates" )"
}

function get_Tlast_message(){
	LAST_MESSAGE_ID=$(cat ${LMidFILE})
	echo "$(curl $CURL_ARGS -X GET "${URL}/getUpdates?" -d offset=${LAST_MESSAGE_ID} -d limit=1 )"
}
